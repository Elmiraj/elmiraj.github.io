{"meta":{"title":"elmiraj","subtitle":null,"description":"工具人","author":"elmiraj","url":""},"pages":[{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-05-15T23:39:12.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-05-15T23:39:12.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-05-15T23:39:12.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-05-15T23:39:12.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... function bot_ui_ini() { var botui = new BotUI(\"hello-mashiro\"); botui.message.add({ delay: 800, content: \"Hi, there111👋\" }).then(function () { botui.message.add({ delay: 1100, content: \"这里是 Mashiro\" }).then(function () { botui.message.add({ delay: 1100, content: \"一个可爱的蓝孩子~\" }).then(function () { botui.action.button({ delay: 1600, action: [{ text: \"然后呢？ 😃\", value: \"sure\" }, { text: \"少废话！ 🙄\", value: \"skip\" }] }).then(function (a) { \"sure\" == a.value && sure(); \"skip\" == a.value && end() }) }) }) }); var sure = function () { botui.message.add({ delay: 600, content: \"😘\" }).then(function () { secondpart() }) }, end = function () { botui.message.add({ delay: 600, content: \"![...](https://view.moezx.cc/images/2018/05/06/a1c4cd0452528b572af37952489372b6.md.jpg)\" }) }, secondpart = function () { botui.message.add({ delay: 1500, content: \"目前就读于上海财经大学\" }).then(function () { botui.message.add({ delay: 1500, content: \"向往技术却误入商科，但后来喜欢上了经济学…\" }).then(function () { botui.message.add({ delay: 1200, content: \"因为数据分析也需要Coder嘛\" }).then(function () { botui.message.add({ delay: 1500, content: \"主攻 R 语言和 Python，略懂 STATA，偶尔也折腾 HTML/CSS/JavaScript/PHP\" }).then(function () { botui.message.add({ delay: 1500, content: \"研究的方向，是经济/金融方向的数据分析（data science）以及机器学习（machine learning）\" }).then(function () { botui.message.add({ delay: 1800, content: \"喜欢画画，希望有一天能够被称为画师\" }).then(function () { botui.action.button({ delay: 1100, action: [{ text: \"为什么叫Mashiro呢？ 🤔\", value: \"why-mashiro\" }] }).then(function (a) { thirdpart() }) }) }) }) }) }) }) }, thirdpart = function () { botui.message.add({ delay: 1E3, content: \"Mashiro以及站名都来自一部动画，因为和主角有一样的爱好~ 如果有兴趣可以找找首页上的视频~\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"为什么是白猫呢？ 🤔\", value: \"why-cat\" }] }).then(function (a) { fourthpart() }) }) }, fourthpart = function () { botui.message.add({ delay: 1E3, content: \"因为对GitHub有种执念… \" }).then(function () { botui.message.add({ delay: 1100, content: \"而且我真的是猫控！\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"域名有什么含意吗？(ง •_•)ง\", value: \"why-domain\" }] }).then(function (a) { fifthpart() }) }) }) }, fifthpart = function () { botui.message.add({ delay: 1E3, content: \"emmmm，看备案信息你就知道了=.= 本来想要zheng.xin的，但50万真买不起。。\" }).then(function () { botui.message.add({ delay: 1600, content: \"那么，仔细看看我的博客吧？ ^_^\" }) }) } } bot_ui_ini()","keywords":"关于"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-05-15T23:39:12.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-05-15T23:39:12.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-05-15T23:39:12.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-05-30T12:17:59.000Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-05-15T23:39:12.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-05-15T23:39:12.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-05-15T23:39:12.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-05-15T23:39:12.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"Caprice-2019-07-14","slug":"Caprice-2019-07-14","date":"2019-07-14T06:51:21.000Z","updated":"2019-07-26T08:05:41.308Z","comments":true,"path":"2019/07/14/Caprice-2019-07-14/","link":"","permalink":"/2019/07/14/Caprice-2019-07-14/","excerpt":"","text":"到现在都还没正确地建立属于自己的知识体系，需要很深入地取思考，到底哪种方式适合自己，以下是思考的过程： 要随时可记，随时可写，也就是说，最好手机端和 pc 端互通，这一点很关键。或者说，即使不互通，手机上的只言片语、剪切片段也需要及时地同步到电脑中，或者云中 既然要同步到云中，那么就需要选择一个可靠性高地云，或者说直接存在硬盘中，但是直接存在硬盘中读取不方便，只能通过电脑读取，无法通过手机读取。所以还是要存在云中，而且取用方便。 那么选择一个合适的云就很关键了。自己建服务器不稳定，收费高，使用率低，完全没有必要，还不如使用产品化的工具，例如 evernote 之类的笔记型应用 但是 evernote 对于我来说，确实用得少，而且我感觉不好用，所以不如这样，用笔记写详细，用 workflowy 写大纲，或者直接用笔记本（笑），笔记本更不好用，不过也说不定呢～现在先试试 thebrain 这个思维导图，看有没有什么比较好的体验。","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"Caprice","slug":"Caprice","permalink":"/tags/Caprice/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"ORA-00054:resource busy and acquire with NOWAIT specified or timeout expired","slug":"ORA-00054-resource-busy-and-acquire-with-NOWAIT-specified-or-timeout-expired","date":"2019-07-08T10:53:42.000Z","updated":"2019-07-14T07:29:03.971Z","comments":true,"path":"2019/07/08/ORA-00054-resource-busy-and-acquire-with-NOWAIT-specified-or-timeout-expired/","link":"","permalink":"/2019/07/08/ORA-00054-resource-busy-and-acquire-with-NOWAIT-specified-or-timeout-expired/","excerpt":"","text":"Oracle 报错这个错误按照字面意思就是：资源忙，被占用。 处理思路查到谁在占用资源，并且杀掉占用该资源的 Session 即可。 可能产生原因 创建索引时产生的锁 dml 语句产生的锁 索引创建时加上关键字 online 时产生的锁 问题处理 检查哪个用户占用了资源 &gt; select l.session_id,o.owner,o.object_name from v$locked_object l,dba_objects o where l.object_id=o.object_id; SESSION_ID OWNER OBJECT_NAME 2205 REPORTUSER T_USER_LABEL 利用 session_id 查出更详细的信息 &gt; SELECT sid, serial#, username, oSUSEr, terminal,program ,action, prev_exec_start FROM v$session where sid = 2205; SID SERIAL# 2205 3045 根据查出来的 SID 和 SERIAL# 杀掉占用资源的会话 &gt; alter system kill session &#39;2205,3045&#39;;","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"9种处理异常的最佳实践","slug":"9种处理异常的最佳实践","date":"2019-06-27T11:18:24.000Z","updated":"2019-07-26T08:02:56.713Z","comments":true,"path":"2019/06/27/9种处理异常的最佳实践/","link":"","permalink":"/2019/06/27/9种处理异常的最佳实践/","excerpt":"","text":"翻译自：9 Best Practices to Handle Exceptions in Java Java 中的异常处理并不是一个简单的主题。初学者觉得它很难懂，即使是成熟的开发者也会花数小时讨论应该抛出或者处理哪个异常。这就是为什么大多数的开发团队都有一套自己的规则。如果你是一个团队的新人，你可能会惊讶于他们的规则可能比你所接触过的所有规则都要复杂繁琐。尽管如此，依然有一些大多数团队使用的最佳实践。以下会介绍9种最佳实践来帮助你起步或者提升你的异常处理能力。 在 Finally 块中清理资源或者使用 try-with-resource 声明它经常出现在当你在 try 块中使用资源时，像一个输入流（InputStream），使用后必须将它关闭。通常错误会出现在 try 块之后的关闭资源。 public void doNotCloseResourceInTry() { FileInputStream inputStream = null; try { File file = new File(&quot;./tmp.txt&quot;); inputStream = new FileInputStream(file); // use the inputStream to read a file // do NOT do this inputStream.close(); } catch (FileNotFoundException e) { log.error(e); } catch (IOException e) { log.error(e); } } 问题就在于这个方法看起来完美无缺只要没有异常抛出来。try 块的所有声明都会被执行，然后资源会被关闭。但是你出于一些理由加上了 try 块。你调用一个或多个可能抛异常的方法，或者你自己抛出个异常。这就意味着你可能到不了 try 块的最后了。结果就是，你也关闭不了这个资源。所以，你应该把你所有的清理资源的代码放在 finally 块中或者使用 try-with-resource 声明。 使用 Finally 块相比于 try 块的最后几行，finally 块始终会被执行。即使是在成功运行的 try 块之后，抑或是 catch 块捕获异常之后。由于这个原因，你能保证清理了所有已开启的资源。 public void closeResourceInFinally() { FileInputStream inputStream = null; try { File file = new File(&quot;./tmp.txt&quot;); inputStream = new FileInputStream(file); // use the inputStream to read a file } catch (FileNotFoundException e) { log.error(e); } finally { if (inputStream != null) { try { inputStream.close(); } catch (IOException e) { log.error(e); } } } } Java 7 的 try-with-resource 声明另一个选择是 try-with-resource 声明，我在我的另一篇文章 introduction to Java exception handling 中解释了更多的细节。如果你的资源实现了 AutoCloseable 接口，你就可以使用它。这也是大多数 Java 基础资源所使用的方法。当你在 try 语句中打开资源时，它就能自动在 try 块运行结束时被关闭，或者捕获异常。 public void automaticallyCloseResource() { File file = new File(&quot;./tmp.txt&quot;); try (FileInputStream inputStream = new FileInputStream(file);) { // use the inputStream to read a file } catch (FileNotFoundException e) { log.error(e); } catch (IOException e) { log.error(e); } } 倾向于特定的异常你抛出的异常越明确越好。永远要想到不知道你代码的下一个继任者，或者几个月后的你自己，需要调用这个方法并且处理异常。所以要确保提供给他们尽可能多的信息。这将会使你的 API 理解起来更加轻松。这样做的结果就是，调用你方法的调用者能够更好地处理异常或者防止额外的检查。所以始终要去找最佳的异常方法，例如，用 NumberFormatException 取代 IllegalArgumentException。防止抛出未指定的异常。 public void doNotDoThis() throws Exception { ... } public void doThis() throws NumberFormatException { ... } 将你特定的异常用文档记下来无论何时你在方法中特定异常，你都应当用 JavaDoc 记录下来。这跟之前的最佳实践都有同样的目的：为调用者提供尽可能多的信息，以使他防止或者处理这些异常。所以，确保你的 JavaDoc 中加上了 @throws 注释来描述你可能造成异常的情况。 /** * This method does something extremely useful ... * * @param input * @throws MyBusinessException if ... happens */ public void doSomething(String input) throws MyBusinessException { ... } 抛出具有描述性的信息在这个最佳实践之后的想法和前面两个相同。但是这一次，你不用给你方法的调用者提供信息。当这个异常被写入日志文件中或者打印在控制台时，这个异常的信息就会被所有想要知道发生了什么的人所理解。所，，它应该尽可能准确地描述这个问题，提供更加接近的信息以便理解这些异常事件。可别说我说错了，你可不用写一大推的文字。但是你应该用一两个短句来描述这个异常的原因。这将会帮助你们的运维团队理解那些严重的问题，这也能让你更加轻松地分析任何的服务问题。如果你抛出了很明确的异常，它的类名已经很明确地描述了它会抛出的错误的方式。所以，你不需要提供大量的额外的信息。例如，NumberFormatException。当你给 String 一个错误的类型时，它会通过 java.lang.Long 构造器抛出异常。 try { new Long(&quot;xyz&quot;); } catch (NumberFormatException e) { log.error(e); } NumberFormatException 这个名字已经告诉你了这个问题的所在。它抛出的信息只需要提供输入的字符串就可以定位到问题所在。如果异常类的名称没有解释得这么清楚，你就需要在打印出的消息中提供确切的信息。 17:17:26,386 ERROR TestExceptionHandling:52 - java.lang.NumberFormatException: For input string: &quot;xyz&quot; 首先捕获最明确的异常这一点大多数的 IDE 会都能够帮助到你。当你想要首先捕获不那么明确的异常时它们就会提醒你这个问题。问题在于只有第一个符合异常的捕获块会被执行。也就是说，如果你首先捕获了 IllegalArgumentException，你永远不会到达处理地更明确的 NumberFormatException 捕获块，因为它是 IllegalArgumentException 的子类。永远第一个捕获最明确的异常并且将不那么明确的异常放在你列表的最后。在下面的代码段中就是这样一个例子。第一个捕获块处理了所有的 NumberFormatException，第二个捕获块捕获了所有的不为 NumberFormatException 的 IllegalArgumentException。 public void catchMostSpecificExceptionFirst() { try { doSomething(&quot;A message&quot;); } catch (NumberFormatException e) { log.error(e); } catch (IllegalArgumentException e) { log.error(e) } } 不要捕获 Throwable 类Throwable 是所有异常和错误的父类。你能在捕获块中使用它，但是你不应该这么做！如果你在捕获框中使用 Throwable ，它不仅会捕获所有的异常，而且还会捕获所有的错误。错误应该被 JVM 抛出以便确定严重的问题，而不是程序想要去处理的。典型的例子是 OutOfMemeryError 或者 StackOverflowError。导致这两个问题的原因都是程序控制的外部状况并且程序不能处理它。所以，最好不要捕获 Throwable 除非你百分之百确定你处于异常的情况，并且你能够或者需要处理这些错误。 public void doNotCatchThrowable() { try { // do something } catch (Throwable t) { // don&#39;t do this! } } 不要忽略异常你曾经分析过只执行了你测试用例的第一部分的 bug 报告吗？这通常是忽略异常造成的。程序员或许很确定它不会被抛出，并且会加一个不会被处理或者记录它的捕获块。当你找到这个块时，你大概率也会找到其中一个著名的“这个永远不会发生”的注释。 public void doNotIgnoreExceptions() { try { // do something } catch (NumberFormatException e) { // this will never happen } } 那么，你可能正在分析一个不可能发生的问题。所以，请不要忽略异常。你不知道未来这个代码会变成什么样子。可能有人会移除防止异常事件的验证而不去确认是否会出问题。或者说抛出异常的代码发生了改变现在又在相同的类中抛出了多个异常，调用的代码并没有防止所有的这些异常。你应该至少写一个日志信息来告诉所有人这些难以置信的问题已经发生了，其他人需要去检查一下。 public void logAnException() { try { // do something } catch (NumberFormatException e) { log.error(&quot;This should never happen: &quot; + e); } } 不要记录和抛出这可能是这份最佳实践中最容易被忽略的。你可以找到大量的代码片段甚至包里面都有获取、记录和重新抛出的异常。 try { new Long(&quot;xyz&quot;); } catch (NumberFormatException e) { log.error(e); throw e; } 当一个异常发生的时候，人们可以非常简单地记录这个异常，然后重新抛出，调用的代码就能在合适的地方处理它。但是这样会为同一个异常写入大量的错误信息。 17:44:28,945 ERROR TestExceptionHandling:65 - java.lang.NumberFormatException: For input string: &quot;xyz&quot; Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input string: &quot;xyz&quot; at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Long.parseLong(Long.java:589) at java.lang.Long.(Long.java:965) at com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.java:63) at com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:58) 这些额外的消息并不会加入任何信息。就像最佳实践4所说的一样，异常信息应该描述异常的事件。堆栈信息会告诉你哪个类、方法和行的异常被抛出了。如果你需要加入额外的信息，你应该捕获这些异常并且将之包装成自定义的。但是要保证遵循最佳实践9。 public void wrapException(String input) throws MyBusinessException { try { // do something } catch (NumberFormatException e) { throw new MyBusinessException(&quot;A message that describes the error.&quot;, e); } } 所以，只捕获你想要处理的异常。其它的，在方法签名中具体说明，让调用者小心就行了。 在不消耗异常的情况下包装它有时候你最好捕获一个基本异常并且包装成自定义方法。举一个很典型的例子：一个程序或者框架的详细的业务异常。这允许你添加额外的信息，还可以实现你异常的明确处理。当你这样做时，确保将原本的异常设为原因。Exception 类提供了明确的构造方法可以将 Throwable 当作一个参数。另外，你失去了堆栈信息和原始异常信息，这样会导致你很难去分析异常事件和导致异常的原因。 public void wrapException(String input) throws MyBusinessException { try { // do something } catch (NumberFormatException e) { throw new MyBusinessException(&quot;A message that describes the error.&quot;, e); } } 总结如你所见，当你抛出和捕获异常时又很多问题需要去考虑。它们中的大多数都以提高你代码的可读性或者你接口的可用性作为目标。异常大多数时候同时是一个错误处理机制和一个沟通媒介。所以，你应该确保讨论最佳的实践并且与你的同事制定一定的规则，这样每个人都能理解和使用这些平常的概念。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"五种开源协议的区别","slug":"五种开源协议的区别","date":"2019-06-24T02:41:24.000Z","updated":"2019-06-24T12:08:54.000Z","comments":true,"path":"2019/06/24/五种开源协议的区别/","link":"","permalink":"/2019/06/24/五种开源协议的区别/","excerpt":"","text":"五种开源协议的比较（BSD, Apache, GPL, LGPL, MIT） BSD 开源协议BSD 开源协议是一个给予使用者很大自由的协议，可以自由地使用、修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。以 BSD 协议作为基础做二次开发时，需要满足三个条件： 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的 BSD 协议，如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的 BSD 协议 可以用开源代码的作者/机构名字和原来产品的名字做市场推广 BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。 Apache License 2.0Apache License 是 Apache 采用的协议，与 BSD 类似，鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也与 BSD 类似： 如果修改了代码，需要在被修改的文件中说明，如果再发布的产品中包含一个 Notice 文件，则在 Notice 文件中需要带有 Apache License，可以在 Notice 中增加自己的许可，但不可以表现为对 Apache License 构成修改 在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议、商标、专利声明和其它原作者规定需要包含的说明。 GPL(GNU General Public License)Linux 即是采用 GPL 协议。GPL 的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源，但不允许修改后和衍生的代码作为闭源的商业软件发布和销售。这就是为什么我们能使用各种免费的 Linux，包括商业公司的 Linux 和 Linux 上各种由个人、组织以及商业软件公司开发的免费软件了。GPL 协议的主要内容是：只要在一个软件中使用（“使用”指类库引用，修改后的代码或者衍生代码）GPL 协议的产品，则该软件产品必须也采用 GPL 协议，必须也是开源和免费的，这就是所谓的“传染性”。GPL 协议的产品作为一个单独的产品使用没有任何问题，还可以享受免费的优势。由于 GPL 严格要求使用了 GPL 类库的软件产品必须使用 GPL 协议，对于使用 GPL 协议的开源代码、商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和&gt;二次开发的基础 LGPL(GNU Lesser General Public License)LGPL 是 GPL 的一个主要为类库使用设计的开源协议。和 GPL 要求任何使用/修改/衍生自 GPL 类库的软件必须采用 GPL 协议不同，LGPL 允许商业软件通过类库引用方式使用 LGPL类库而不需要开源商业软件的代码，这使得采用 LGPL 协议的开源代码可以被商业软件作为类库引用并发布和销售。但是如果修改 LGPL 协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生代码都必须采用 LGPL 协议。因此 LGPL 协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以 LGPL 协议代码为基础，通过修改和衍生的方式做二次开发的商业软件使用。GPL/LGPL 都保障了原作者的知识产权，避免有人利用开源代码复制并开发类似的产品 MITMIT 和 BSD 一样有着宽泛的许可协议，作者只想保留版权，而无任何其它的限制，也就是说，用户必须在发行版里包含原许可协议，无论是以二进制发布的还是以源代码发布的。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"OpenSource","slug":"OpenSource","permalink":"/tags/OpenSource/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Caprice-2019-06-23","slug":"Caprice-2019-06-23","date":"2019-06-23T08:19:45.000Z","updated":"2019-07-26T08:05:20.748Z","comments":true,"path":"2019/06/23/Caprice-2019-06-23/","link":"","permalink":"/2019/06/23/Caprice-2019-06-23/","excerpt":"","text":"是不是大多数研究和学习都是这样，越深入，暴露的问题就会越多，不懂的也就越多。所谓事情越解决就会越多，这世上从没有解决完了的事情，对吧 越长大，越来越多的事情就会变得毫无意义；又或者正好相反，越来越多的事情变得有了意义。这取决于什么呢？还是说这只是人类的自由选择？","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"Caprice","slug":"Caprice","permalink":"/tags/Caprice/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"Everything about Redis","slug":"Everything-about-Redis","date":"2019-06-23T05:31:52.000Z","updated":"2019-06-25T00:51:36.000Z","comments":true,"path":"2019/06/23/Everything-about-Redis/","link":"","permalink":"/2019/06/23/Everything-about-Redis/","excerpt":"","text":"什么是 RedisRedis(REmote DIctionary Server) 是一个 key-value 存储系统，开源，使用 ANSI C 语言编写，遵守 BSD 协议，支持网络，可基于内存亦可持久化的日志型 Key-Value 数据库，并且提供多种语言的 API。通常被称为数据结构服务器，因为 value 可以是 String, Map, list, sets, sorted sets 等类型。 ANSI C 语言：ANSI（美国国家标准化组织）对 C 语言进行的标准化 五种开源协议的比较（BSD, Apache, GPL, LGPL, MIT） Redis 优势 性能极高 - Redis 能读的速度是 110k次/s，写的速度为 81k次/s 丰富的数据类型 - Redis 支持 Strings, Lists, Hashed, Sets, Ordered Sets 等数据类型操作 原子 - Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作合并后的原子性执行 丰富的特性 - Redis 支持 publish/subscribe，队列， key 过期等特性 原子性：事务是指对系统进行的一组操作，为了保证系统的完整性，事务需要具有 ACID 特性 原子性（Atomic）一个事务包含多个操作，这些操作要么全部执行，要么全部都不执行。实现事务的原子性，需要支持回滚操作，在某个操作失败后，回滚到事务执行之前的状态。 回滚：大多数 DB 在实现事务时，是在事务操作的数据快照上进行的（比如，MVCC） MVCC：提到 MVCC，就需要先了解事务的并发控制： 事务并发最常见的三种并发控制机制： 悲观并发控制（PCC: Pessimistic Concurrency Control）：最常见的并发控制机制，也就是锁控制不同的事务对同一份数据的获取是保证数据库一致性的最根本的方法。如果能够让事务在同一时间对同一资源有着独占的能力，那么就可以保证操作同一资源的不同事务不会相互影响。最简单、应用最广的方法就是使用锁来解决，当事务需要对资源进行操作时需要先获得资源对应的锁，保证其它事务不会访问到该资源后，再对资源进行各种操作；在 PCC 中，数据库程序对于数据被修改持悲观的态度，在数据处理的过程中都会被锁定，以此来解决竞争的问题。 读写锁为了最大化数据库事务的并发能力，数据库中的锁被设计为两种模式，分别是共享锁和互斥锁。当一个事务获得共享锁是、后，它只可进行读操作，所以共享锁也叫做读锁；当一个事务获得一行数据的互斥锁时，就可以对该行数据进行读写操作，所以互斥锁也叫写锁。共享锁和互斥锁之间还有“共享”和“互斥”的关系，也就是多个事务可以同时获得某一行数据的共享锁，但是互斥锁与共享锁和其它的互斥锁并不兼容。多个事务同时写入同一数据难免会发生各种问题。如果当前事务没法获得该行数据对应的锁时就会陷入等待状态，知道其它事务将当前数据对应的锁释放才可以获得锁并执行相应的操作。 两阶段锁协议 乐观并发控制：乐观锁 多版本并发控制：MVCC，可以与前两者中的任意一种机制结合使用，以提高数据库的读性能， Redis 对象类型 每个 key/value 都是使用对象表示，比如： redis&gt; SET message &quot;hello redis&quot; 其中 key 是 message，是一个包含了字符串“message”的对象，而 value 是一个包含了“heello redis”的对象。Redis 共有五种对象类型： 类型常量 对象的名称 REDIS_STRING 字符串对象 REDIS_LIST 列表对象 REDIS_HASH 哈希对象 REDIS_SET 集合对象 REDIS_ZSET 有序集合对象 Redis 中的一个对象的结构体表示如下： typedef struct redisObject { //类型 unsigned type:4; //编码方式 unsigned encoding:4; //引用计数 int refcount; //指向对象的值 void *ptr; } robj; type 表示该对象的对象类型，为了提高存储效率与程序执行效率，每种对象的底层数据结构实现都可能不止一种。encoding 就表示了对象底层所使用的编码。 * Redis 对象底层数据结构 编码常量 编码所对应的底层数据结构 REDIS_ENCODING_INT long 类型的整数 REDIS_ENCODING_EMBSTR embstr 编码的简单动态字符串 REDIS_ENCODING_RAW 简单动态字符串 REDIS_ENCODING_HT 字典 REDIS_ENCODING_LINKEDLIST 双端链表 REDIS_ENCODING_ZIPLIST 压缩列表 REDIS_ENCODING_INTSET 整数集合 REDIS_ENCODING_SKIPLIST 跳跃表和字典 字符串对象字符串对象的编码可以是 int, raw 或者 embstr。如果一个字符串的内容可以转换为 long，那么该字符串就会被转换成 long 类型，对象的 ptr 就会指向该 long，并且对象类型也用 int 类型表示。普通的字符串，如果字符串对象的长度小于 39 字节，就用 embstr 对象，否则用传统的 row 对象。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"Redis","slug":"Redis","permalink":"/tags/Redis/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"提供隐私保护和过滤的DNS服务","slug":"提供隐私保护和过滤的DNS服务","date":"2019-06-21T02:07:48.000Z","updated":"2019-06-21T14:45:08.000Z","comments":true,"path":"2019/06/21/提供隐私保护和过滤的DNS服务/","link":"","permalink":"/2019/06/21/提供隐私保护和过滤的DNS服务/","excerpt":"","text":"翻译自：DNS Servers That Offer Privacy and Filtering 最新的 DNS 服务 IP 都是很好记的，且提供隐私保护和过滤功能如果你是一名程序员、系统管理员或者任何一种 IT 工作者，你大概都有自己的一套检测问题的 IP 地址。如果你像我一样，你可能多年以来都使用的是同一套。 这些 IP 的用法为： 测试 ping 连接 使用 dig 或者 nslookup 方法寻找 DNS 解决方案 更新一个系统的永久 DNS 设置 大部分 DNS 服务允许用户 ping 它们 我喜欢使用 DNS 服务因为我能用它来测试连接和名称解决方案，我长期使用的是 Google DNS 服务： 8.8.8.8 8.8.4.4 … 但是它们不支持任何过滤，而且近年来我越发对发送我所有的 DNS 请求给 Google 而担心。 思科收购了 OpenDNS，从而诞生了 Umbrella 可选择的 Google DNS在某些时期我因为思科 Umbrella 有 URL 过滤功能而选择它。它们维护了一个高危 URL 的列表且能自动拦截，保护用户免遭恶意软件的威胁。 208.67.222.222 208.67.220.220 OpenDNS 服务很棒，但是我必须随时看着它。多年以后，新的 DNS 服务推出了，它们不仅专注于速度和功能，还非常好记。 IBM 的 Quad 9 就是既好记又有过滤功能的服务之一，它的 IP 简单到只有4个9。 9.9.9.9 我猜它们已经在启动时就会被冲垮了，或者它们的过滤还没有调整好 我在 Quad9 刚出来的时候试了一段时间，但是我发现它有点慢。我想它们现在已经修复了这个问题，但是还有更多表面以下的东西。 进入CloudFlare谷歌、思科和 IBM 已经提供了几个很有趣的选项，而现在向我们走来的是 CloudFlare。 它不仅提供了过滤的功能，而且它更加专注于隐私。 一些其它的 DNS 服务或许会宣称它们的服务是安全的因为它们支持 DNSSEC。确实这样是安全的，但是这些服务的用户却很讽刺地并不能被 DNS 公司自己所保护。很多这些公司从它们的 DNS 客户身上收集数据以用于商业用途。所幸的是，1.1.1.1 并不关心什么用户数据。日志只保存24小时以用作调试之用，然后它们就被清空了。 对于我来说最酷的是它的接近完美的易记忆指数： 1.0.0.1 压缩成 1.1，你就能真真切切地使用 ping 1.1 进行测试 1.1.1.1 1.0.0.1 多酷啊～ 它们不会过滤你的 URL，但是它们有意识地避免记录或者跟踪用户，这真的很棒。 诺顿 ConnectSafe DNS诺顿也有公共 DNS 服务，它们专注于多层级的 URL 内容过滤。 拦截恶意和欺诈地址 199.85.126.10 199.85.127.10 拦截色情内容 199.85.126.20 199.85.127.20 拦截成人内容 199.85.126.30 199.85.127.30 我的推荐性能固然重要，而且它取决于你身处哪里，但是最近的测试我发现所有这些选择都相当敏感。 对于我来说是以下这样： 如果你更关心隐私、速度和易记忆性，我推荐 CloudFlare: 1.1.1.1 1.0.0.1 我发现两家公司所宣称的过滤对于我的口味来说都太难以下咽了，两家说实话都太像边缘营销了 如果你想要 URL 过滤，我推荐你 Quad9 而不是 而不是 Umbrella 因为它更容易记忆，且看起来更专注于多个威胁情报来源 9.9.9.9 如果你想要多层级的 URL 过滤，你最好使用诺顿的服务，但是我个人更倾向于 Quad9。但是我认为诺顿作为保护整个学校或者通过最严格的选项强迫它们的 DNS 来说也是个不错的选择 总结最终答案——如果必须要选一个的话——我有两个你值得记住的推荐 更在乎速度和隐私：1.1.1.1. 更在乎过滤：9.9.9.9","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"/tags/HTML/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Book-Java 编程思想笔记","slug":"Book-Java-编程思想笔记","date":"2019-06-16T05:55:24.000Z","updated":"2019-06-17T05:39:12.000Z","comments":true,"path":"2019/06/16/Book-Java-编程思想笔记/","link":"","permalink":"/2019/06/16/Book-Java-编程思想笔记/","excerpt":"","text":"Java 编程思想 我们必须建立起在机器模型（位于“解空间”内，对问题建模的地方，例如计算机）和实际待解问题的模型（位于“问题空间”内，是问题存在的地方，例如一项业务）之间的联系 面向对象的五个基本特性 万物皆为对象 程序是对象的集合，它们通过发送消息来告知彼此所要做的。 每个对象都有自己的由其他对象所构成的存储 每个对象都拥有其类型，每个对象都是某个类的实例 某一特定类型的所有对象都可以接收同样的消息 对象具有状态、行为和标识。这意味着每个对象都可以拥有内部数据（给出了该对象的状态）和方法（产生行为），并且每一个对象都可以唯一地与其他对象区分开，每一个对象在内存中都有一个唯一的地址。 每个对象都有一个接口以某种方式产生对对象的请求，使对象完成各种任务，如打开灯等，每个对象都只能满足某些请求，这些请求由对象的接口（interface）所定义，决定接口的便是类型。以电灯为例： Light light = new Light(); light.on(); 类型/类的名称为 Light，特定的 Light 对象的名称是 light，可以向 Light 对象发出的请求是：打开、关闭等等。以下列方式创建一个 Light 对象：定义这个对象的“引用”（light），然后调用 new 方法创建该类型的新对象。 隐藏具体实现访问控制让 API 调用者无法触及他们不应该触及的部分，允许库设计者可以改变类内部的工作方式而不用担心会影响到 API 调用者。Java 的三个关键字在类的内部设定边界：public, private, protected。这些访问指定词（access specifier）决定了紧跟其后被定义的东西可以被谁使用。public 表示紧随其后的元素对任何人都是可用的，private 表示除类型创建者和类型的内部方法外的任何人都不能访问的元素。protected 与 private 作用相当，差别仅在于继承的类可以访问 protected 成员，但不能访问 private 成员。 一切都是对象","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"读书","slug":"读书","permalink":"/tags/读书/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Caprice-2019-06-10","slug":"Caprice-2019-06-10","date":"2019-06-10T14:49:21.000Z","updated":"2019-07-26T08:04:59.282Z","comments":true,"path":"2019/06/10/Caprice-2019-06-10/","link":"","permalink":"/2019/06/10/Caprice-2019-06-10/","excerpt":"","text":"命运已经决定，那些前往月球探索的人将会在月球上安息。这些勇敢的宇航员知道他们的获救没有希望，但他们也知道人类将从他们的牺牲中看到希望。对于每个在未来的夜晚仰望月球的人来说，会知道有人长眠在那里的某个角落。 ——尼克松","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"Book-深入理解 Java 虚拟机","slug":"Book-深入理解-Java-虚拟机","date":"2019-06-09T12:13:44.000Z","updated":"2019-06-16T05:55:40.000Z","comments":true,"path":"2019/06/09/Book-深入理解-Java-虚拟机/","link":"","permalink":"/2019/06/09/Book-深入理解-Java-虚拟机/","excerpt":"","text":"深入理解 Java 虚拟机：JVM 高级特性与最佳实践自动内存管理机制Java 内存区域与内存溢出异常 运行时数据区域 程序计数器（Program Counter Register） 这是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。 字节码解释器：通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成 Java 虚拟机的多线程 通过线程轮流切换并分配处理器执行时间的方式来实现，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，并且各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OOME 情况的区域 OOME: OutOfMemeryError 内存溢出 Java 虚拟机栈（Java Virtual Machine Stacks） 特点：线程私有，生命周期与线程相同。 虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行时都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程 栈帧：方法运行期的基础数据结构 虚拟机栈中的局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。Java 虚拟机规范对这个区域规定了两种异常情况： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 如果虚拟机栈可以动态扩展（当前大部分 Java 虚拟机都可以动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请足够的内存时会抛出 OOME。 基本数据类型：boolean, byte, char, short, int, float, long, double，64位的 long 和 double 类型的数据会占用两个局部变量空间（Slot），其余的类型只占用一个。 对象引用：reference 类型，不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其它与此对象相关的位置 returnAddress类型：指向一条字节码指令的地址 本地方法栈（Native Method Stacks） 与虚拟机栈的区别是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，本地方法栈则是为虚拟机使用到的 Native 方法服务。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OOME。 Java 堆（Java Heap） Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC 堆”（Garbage Collected Heap）。 Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，既可以实现成固定大小的，也可以是可扩展的。如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OOME 异常。 方法区（Method Area） 与 Java 堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然虚拟机规范鈀方法区描述为堆的一个逻辑部分，但是它的别名却叫做 NonHeap（非堆），目的是与 Java 堆区分开来。 虚拟机规范对这个区域相当宽松，甚至可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出 OOME 异常 运行时常量池（Runtime Constant Pool） 方法区的一部分，Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息时常量池（Constant Pool Table），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 收到方法区内存的限制，当常量池无法再申请到内存时会抛出 OOME 异常 直接内存（Direct Memory） 在 JDK 1.4 中加入了 NIO(New Input/Output) 类，引入了一种基于通道（Channel）和缓冲区（Buffer）的 I/O 方式，可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，避免了在 Java 堆和 Native 堆中来回复制数据 OOME 异常 Java 堆溢出 Java 堆内存的 OOM 异常是实际应用中最常见的内存溢出异常情况。要解决这个区域的异常，一般的手段是首先通过内存映像分析工具（如 Eclipse Memory Analyzer）对 dump 出来的堆转储快找进行分析，要先分析清楚是内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。 如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的引用链，这样就能找到泄漏对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息以及 GC Roots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。 如果不存在泄漏，则内存中的对象都存活着，此时应该检查虚拟机的堆参数（-Xmx 与 -Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。 虚拟机栈和本地方法栈溢出 对于 HotSpot 来说，-Xoss 参数（设置本地方法栈大小）虽然存在，但实际上是无效的，栈容量只由 -Xss 参数设定。关于虚拟机栈和本地方法栈，在 Java 虚拟机规范中描述了两种异常： 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出 OOME 异常 如果操作系统分配给每个进程的内存时有限制的，如 2 GB，虚拟机提供了参数来控制 Java 堆和方法区的这两部分内存的最大值。剩余的内存为 2 GB 减去 Xmx （最大堆容量），再减去 MaxPermSize（最大方法区容量），程序计数器消耗的内存很小，可以忽略，那么剩下的内存就由虚拟机栈和本地方法瓜分了。 每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存消耗掉 运行时常量池溢出 如果要向运行时常量池中添加内容，最简单的做法就是使用 String.intern() 这个 Native 方法，作用是如果池中已经包含一个等于此 String 对象的字符串，则返回代表池中这个字符串的 String 对象，否则，将此 String 对象包含的字符串添加到常量池中，并返回此 String 对象的引用。 垃圾收集器与内存分配策略","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"/tags/JVM/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Caprice-2019-06-08","slug":"Caprice-2019-06-08","date":"2019-06-08T08:24:19.000Z","updated":"2019-06-08T08:36:54.000Z","comments":true,"path":"2019/06/08/Caprice-2019-06-08/","link":"","permalink":"/2019/06/08/Caprice-2019-06-08/","excerpt":"","text":"博客越写，越想写的东西就越多，世界上的知识太多，自己想了解的，想记录的也太多。","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"Book-程序员练级攻略书单","slug":"Book-程序员练级攻略书单","date":"2019-06-08T07:40:18.000Z","updated":"2019-06-08T08:12:38.000Z","comments":true,"path":"2019/06/08/Book-程序员练级攻略书单/","link":"","permalink":"/2019/06/08/Book-程序员练级攻略书单/","excerpt":"","text":"编程语言 《代码大全》 《Java 核心技术 · 卷 I》 《重构：改善既有代码的设计》 《修改代码的艺术》 《代码整洁之道》 《程序员的职业素养》 《Spring 实战》 《Spring Boot 实战》 《Effective Java》 《Java 并发编程实战》 《Java 性能权威指南》 《深入理解 Java 虚拟机》 《Java 编程思想》 《精通 Spring 4.x》 《设计模式 可复用面向对象软件的基础》","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"},{"name":"读书","slug":"读书","permalink":"/tags/读书/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"十年如一日，练习编程","slug":"十年如一日，练习编程","date":"2019-06-08T07:04:02.000Z","updated":"2019-06-08T07:31:39.000Z","comments":true,"path":"2019/06/08/十年如一日，练习编程/","link":"","permalink":"/2019/06/08/十年如一日，练习编程/","excerpt":"","text":"十年磨一剑，专注自己的热爱 Ars longa, vita brevis, occasio praeceps, experimentum periculosum, iudicium difficile. 生命很短暂，但是技艺却很高深，机遇转瞬即逝，探索难以捉摸，抉择困难重重。 程序员成功“食谱” 编程是为了兴趣，保持这种充满兴趣的感觉，以便能将其投入到10年/10000小时的编程时间中 在实践中学习。“一个人在某个专业领域方面能够达到最高水平，并不是因为这个人经验增长以后而自动获得的，而是这个人为了进步所作出了专门的努力之后产生的结果”。最有效的学习包括几个要素：明确并且难度适当的任务，适应学习者个人情况，及时的信息反馈，有重新开始和改正错误的机会。 多与其他程序员交流，多阅读他人写的程序。尝试去理解其他人写的代码，看看理解和修正他人写的代码需要花费什么代价。同时也思考，如何规划自己的代码，让它们更容易被其他人理解和维护。 至少学习半打编程语言。包括一种支持类抽象的语言（例如 Java 或者 C++），一种支持函数抽象的语言（例如 Lisp 或者 ML），一种支持语法抽象的语言（例如 Lisp），一种支持声明式编程的语言（例如 Prolog 或者 C++ 模板），一种支持协同程序的语言（例如 Icon 或者 Scheme），一种支持平行并发编程的语言（例如 Sial） 牢记“计算机科学”中包含的“计算机”这个词。了解计算机需要花多长时间执行一条指令，花多长时间从内存中获取一个字（包括缓存命中和不命中两种情况），如果连续从磁盘中获取数据，时间消耗如何？以及需要花多长时间才能在磁盘上定位一个新的位置 尽量参与语言的标准化过程。可以试着加入 ANSI C++ 委员会这样的专业组织，或者也可以从自己的代码规范入手，限定代码缩进是需要两个空格宽还是四个空格宽。 有良好的意识，能尽快适应语言标准化的成果 不是任何人都能成为伟大的艺术家，不过，伟大的艺术家在成名前可能是任何人","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"/tags/Java/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"uv-和-pv-的区别","slug":"uv-和-pv-的区别","date":"2019-06-08T05:18:09.000Z","updated":"2019-06-12T07:50:50.000Z","comments":true,"path":"2019/06/08/uv-和-pv-的区别/","link":"","permalink":"/2019/06/08/uv-和-pv-的区别/","excerpt":"","text":"uv 和 pv 的区别 PV, UV, VV 等是网站分析中最基础，最常见的指标。 PV 即 Page View，网站浏览量 指页面的浏览次数，用以衡量网站用户访问的网页数量。用户每打开一个页面便记录一次 PV，多次打开同一页面则浏览量累计 UV 即 Unique Visitor，独立访客数 指一天内访问某站点的人数，以 cookien 为依据，一天内同一访客的多次访问只记为一个访客 VV 即Visit View，访客的访问次数 用以记录所有访客一天内访问了多少次网站，当访客完成所有浏览并最终关掉网站的所有页面便完成了一次访问，同一访客一天内可能有多次访问行为，访问次数累计","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"ecom","slug":"ecom","permalink":"/tags/ecom/"},{"name":"html","slug":"html","permalink":"/tags/html/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"在成都吃‘独食’","slug":"在成都吃‘独食’","date":"2019-06-03T05:36:05.000Z","updated":"2019-06-08T06:35:27.000Z","comments":true,"path":"2019/06/03/在成都吃‘独食’/","link":"","permalink":"/2019/06/03/在成都吃‘独食’/","excerpt":"","text":"在成都吃“独食” 独食火锅 · 半米屋台 日系居酒屋风格火锅，一人一座，每个位置都有挡板，是完全属于自己的火锅空间。中途需要离座，可以将“我没吃好”的牌子扳出来，很贴心～ 地址：新城市广场，树德里与宁夏街交叉口新城市广场A112 叁带壹火锅 单独小电炉火锅 地址：双楠店，广福桥北街8号 饭团匠 非常日式的风格，吧台设计特别适合一人食，在这里仿佛置身日本的“深夜食堂” 地址：镗鈀街店，镗鈀街67号 喜食记 在这里一人食，完全就是一种对生活的享受 地址：较场坝店，较场坝东街109号 一个人吃饭，不能随便将就，一个人也要好好吃饭。","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"成都","slug":"成都","permalink":"/tags/成都/"},{"name":"美食","slug":"美食","permalink":"/tags/美食/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"Book-白夜行","slug":"Book-白夜行","date":"2019-05-30T13:00:58.000Z","updated":"2019-06-08T08:14:21.000Z","comments":true,"path":"2019/05/30/Book-白夜行/","link":"","permalink":"/2019/05/30/Book-白夜行/","excerpt":"","text":"读书笔记：白夜行 用了两三天读完整部小说，虽然中间已经猜到整个犯罪的动机和过程，但是还是非常引人入胜，想知道最后的结局。雪穗是悲惨的，恋童癖让她的人生产生了天翻地覆的变化，她从此没有了白天，只能像在白夜里行走，而她的光则是恋童癖的儿子，桐原亮司。雪穗因为长得漂亮，所以一直以来为了维持自己的形象，让亮司在背地里做一些见不得人的事情，对雪穗不利的人，最常见的手法是通过伪造被侵犯的现场，让雪穗成为第一发现人，并且在雪穗假惺惺的关心中让自己的形象变得愈发高大起来。亮司同样是一个在白夜中行走的人，他也没有白天，而他的光则是默默补偿雪穗的精神。不管雪穗要求什么，他都会去做，因为他的爸爸侵犯了雪穗，他杀了他爸爸。两个拥有同样悲惨命运的人相依为命，亮司一直在雪穗身边默默保护者雪穗，直到圣诞夜在警察的追捕中坠楼而亡，死在自己的剪刀之上。","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"读书","slug":"读书","permalink":"/tags/读书/"},{"name":"东野圭吾","slug":"东野圭吾","permalink":"/tags/东野圭吾/"},{"name":"日本","slug":"日本","permalink":"/tags/日本/"},{"name":"读过","slug":"读过","permalink":"/tags/读过/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]}]}